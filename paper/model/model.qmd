---
title: "Hansard Interruptions Model"
format: pdf
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r environment setup}
# import libraries
library(tidyverse)
library(arrow)
library(MASS)
library(modelsummary)
```

```{r data import}
# data import
corpus <- read_parquet("../../inputs/corpus_1998_to_2025.parquet")

# filter for just chamber proceedings
corpus <- corpus %>% filter(fedchamb_flag==0)

# get parliament number variable
parl_dates <- ausPH::getParliaments() %>% 
  dplyr::select(PID, Name, DateOpening, ParliamentEnd) %>% 
  # our corpus only goes back to the 38th parliament
  filter(PID>=38)

# add parliament number variable to corpus
corpus <- corpus %>%
  mutate(parliament_num = case_when(
    date >= parl_dates$DateOpening[parl_dates$PID==38] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==38] ~ 38,
    date >= parl_dates$DateOpening[parl_dates$PID==39] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==39] ~ 39,
    date >= parl_dates$DateOpening[parl_dates$PID==40] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==40] ~ 40,
    date >= parl_dates$DateOpening[parl_dates$PID==41] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==41] ~ 41,
    date >= parl_dates$DateOpening[parl_dates$PID==42] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==42] ~ 42,
    date >= parl_dates$DateOpening[parl_dates$PID==43] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==43] ~ 43,
    date >= parl_dates$DateOpening[parl_dates$PID==44] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==44] ~ 44,
    date >= parl_dates$DateOpening[parl_dates$PID==45] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==45] ~ 45,
    date >= parl_dates$DateOpening[parl_dates$PID==46] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==46] ~ 46,
    date >= parl_dates$DateOpening[parl_dates$PID==47] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==47] ~ 47,
    date >= parl_dates$DateOpening[parl_dates$PID==48] ~ 48,
    .default = NA))

# filter for just complete parliament periods (39-47)
corpus <- corpus %>% 
  filter(parliament_num >= 39 & parliament_num <= 47)
```

```{r}
# correction for some incorrect party affiliations that were identified
corpus <- corpus %>% 
  mutate(partyAbbrev = case_when(
    partyAbbrev=="CLP" ~ "LIB",
    partyAbbrev %in% c("NATS WA", "NAT") ~ "NP",
    .default = partyAbbrev)) %>% 
  mutate(partyName = case_when(
      partyAbbrev=="LIB" ~ "Liberal Party of Australia",
      partyAbbrev=="NP" ~ "The Nationals",
      .default = partyName))
```

```{r filtering}
# look at rows that have a missing speech_no
corpus %>% 
  filter(is.na(speech_no)) %>%
  # they're all questions/answers or stage directions or business starts
  filter(question==0 & answer==0 & !name %in% c("Business start","Stage direction"))

# there are no rows with a missing speech number and an interjection
corpus %>% filter(is.na(speech_no) & interject==1)

# can safely filter those out for now
corpus_filtered <- corpus %>% filter(!is.na(speech_no))

# # drop rows where there is a missing gender
# corpus_filtered <- corpus_filtered %>% filter(!is.na(gender))
# 
# # check if there is anyone with a missing displayName (shouldn't be)
# corpus_filtered %>% filter(is.na(displayName)) %>% distinct(name)
```

```{r data prep}
# compute number of speaking turns
n_statements <- corpus_filtered %>% 
  group_by(parliament_num, date, speech_no) %>% 
  mutate(mp_turn_to_speak = displayName[order==min(order)]) %>% 
  ungroup() %>% 
  filter(displayName==mp_turn_to_speak) %>% 
  filter(interject==0) %>% ### to fix manually later - if it is actually their turn they shouldn't be flagged as an interjection
  group_by(mp_turn_to_speak, parliament_num, partyAbbrev) %>% 
  count() %>% 
  ungroup() %>% 
  rename(name = mp_turn_to_speak,
         n_statements = n)

# compute number of interjections
n_interjections <- corpus_filtered %>% 
  group_by(parliament_num, date, speech_no) %>% 
  mutate(mp_turn_to_speak = displayName[order==min(order)],
         party_of_mp_in_turn = partyAbbrev[order==min(order)]) %>% 
  ungroup() %>% 
  filter(displayName!=mp_turn_to_speak) %>% 
  filter(interject==1) %>% 
  group_by(mp_turn_to_speak, parliament_num, party_of_mp_in_turn) %>% 
  count() %>% 
  ungroup() %>% 
  rename(name = mp_turn_to_speak,
         n_times_interjected = n,
         partyAbbrev = party_of_mp_in_turn)

# join n_statements and n_interjections
model_df <- full_join(n_statements, n_interjections, 
                      by=c("name", "parliament_num", "partyAbbrev")) %>% 
  mutate(n_times_interjected = ifelse(is.na(n_times_interjected), 0, 
                                      n_times_interjected))

# add gender into model_df
model_df <- left_join(model_df, corpus_filtered %>% 
                        distinct(name=displayName, partyAbbrev, gender, parliament_num) %>%
                        filter(!is.na(name)),
                      by=c("name", "parliament_num", "partyAbbrev"))

# recode variables correctly
model_df <- model_df %>% 
  mutate(across(c(parliament_num, partyAbbrev, gender), ~ as.factor(.x))) %>% 
  mutate(across(c(n_statements, n_times_interjected), ~ as.numeric(.x))) %>% 
  rename(party=partyAbbrev)

# relevel parliament number and gender
model_df$parliament_num <- relevel(model_df$parliament_num, ref="47")
model_df$gender <- relevel(model_df$gender, ref="male")
model_df$party <- relevel(model_df$party, ref="ALP")

# export model_df
write_csv(model_df, "model_input.csv")
```

```{r}
# check for overdispersion by fitting the poisson model and looking at the ratio of residual deviance and df
poisson_mod <- glm(n_times_interjected ~ parliament_num + party + gender + offset(log(model_df$n_statements)), 
              data=model_df,family = poisson(link="log"))

poisson_mod$deviance/poisson_mod$df.residual

# ratio is 18.72 - rule of thumb is it should be about 1 - indicating extreme overdispersion
```

```{r}
mod <- glm.nb(n_times_interjected ~ parliament_num + party + gender + offset(log(model_df$n_statements)), 
              data=model_df, link=log)

saveRDS(mod, file="model_results.rds")

summary(mod)[["coefficients"]] %>% as_tibble() %>% 
  mutate(name=summary(mod)[["coefficients"]] %>% rownames()) %>% 
  mutate(exp_est = exp(Estimate)) %>% 
  janitor::clean_names() %>% 
  dplyr::select(name, estimate, exp_est, everything()) %>% 
  mutate(across(c(estimate, pr_z, exp_est), ~ round(.x, 4)))

mod$deviance/mod$df.residual

modelsummary(mod)
```
