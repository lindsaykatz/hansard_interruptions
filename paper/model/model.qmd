---
title: "Hansard Interruptions Model"
format: pdf
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r environment setup}
# import libraries
library(tidyverse)
library(arrow)
library(MASS)
library(modelsummary)
```

```{r data import}
# data import
corpus <- read_parquet("../../inputs/corpus_1998_to_2025.parquet")
```

```{r data cleaning}
# filter for just chamber proceedings
corpus <- corpus %>% filter(fedchamb_flag==0)

# get parliament number variable
parl_dates <- ausPH::getParliaments() %>% 
  dplyr::select(PID, Name, DateOpening, ParliamentEnd) %>% 
  # our corpus only goes back to the 38th parliament
  filter(PID>=38)

# add parliament number variable to corpus
corpus <- corpus %>%
  mutate(parliament_num = case_when(
    date >= parl_dates$DateOpening[parl_dates$PID==38] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==38] ~ 38,
    date >= parl_dates$DateOpening[parl_dates$PID==39] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==39] ~ 39,
    date >= parl_dates$DateOpening[parl_dates$PID==40] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==40] ~ 40,
    date >= parl_dates$DateOpening[parl_dates$PID==41] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==41] ~ 41,
    date >= parl_dates$DateOpening[parl_dates$PID==42] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==42] ~ 42,
    date >= parl_dates$DateOpening[parl_dates$PID==43] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==43] ~ 43,
    date >= parl_dates$DateOpening[parl_dates$PID==44] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==44] ~ 44,
    date >= parl_dates$DateOpening[parl_dates$PID==45] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==45] ~ 45,
    date >= parl_dates$DateOpening[parl_dates$PID==46] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==46] ~ 46,
    date >= parl_dates$DateOpening[parl_dates$PID==47] & 
      date <= parl_dates$ParliamentEnd[parl_dates$PID==47] ~ 47,
    date >= parl_dates$DateOpening[parl_dates$PID==48] ~ 48,
    .default = NA))

# filter for just complete parliament periods (39-47)
corpus <- corpus %>% 
  filter(parliament_num >= 39 & parliament_num <= 47)

# correction for some incorrect party affiliations that were identified
corpus <- corpus %>% 
  mutate(partyAbbrev = case_when(
    partyAbbrev=="CLP" ~ "LIB",
    partyAbbrev %in% c("NATS WA", "NAT") ~ "NP",
    .default = partyAbbrev)) %>% 
  mutate(partyName = case_when(
      partyAbbrev=="LIB" ~ "Liberal Party of Australia",
      partyAbbrev=="NP" ~ "The Nationals",
      .default = partyName))

# look at rows that have a missing speech_no
corpus %>% 
  filter(is.na(speech_no)) %>%
  # they're all questions/answers or stage directions or business starts
  filter(question==0 & answer==0 & !name %in% c("Business start","Stage direction"))

# there are no rows with a missing speech number and an interjection
corpus %>% filter(is.na(speech_no) & interject==1)

# can safely filter those out for now
corpus_filtered <- corpus %>% filter(!is.na(speech_no))
```

```{r reshaping}
# compute number of speaking turns
n_statements <- corpus_filtered %>% 
  group_by(parliament_num, date, speech_no) %>% 
  mutate(mp_turn_to_speak = displayName[order==min(order)]) %>% 
  ungroup() %>% 
  filter(displayName==mp_turn_to_speak) %>% 
  filter(interject==0) %>% ### to fix manually later - if it is actually their turn they shouldn't be flagged as an interjection
  group_by(mp_turn_to_speak, parliament_num, partyAbbrev) %>% 
  count() %>% 
  ungroup() %>% 
  rename(name = mp_turn_to_speak,
         n_statements = n)

# compute number of interjections
n_interjections <- corpus_filtered %>% 
  group_by(parliament_num, date, speech_no) %>% 
  mutate(mp_turn_to_speak = displayName[order==min(order)],
         party_of_mp_in_turn = partyAbbrev[order==min(order)]) %>% 
  ungroup() %>% 
  filter(displayName!=mp_turn_to_speak) %>% 
  filter(interject==1) %>% 
  group_by(mp_turn_to_speak, parliament_num, party_of_mp_in_turn) %>% 
  count() %>% 
  ungroup() %>% 
  rename(name = mp_turn_to_speak,
         n_times_interjected = n,
         partyAbbrev = party_of_mp_in_turn)
```

```{r prep model_df}
# join n_statements and n_interjections
model_df <- full_join(n_statements, n_interjections, 
                      by=c("name", "parliament_num", "partyAbbrev")) %>% 
  mutate(n_times_interjected = ifelse(is.na(n_times_interjected), 0, 
                                      n_times_interjected))

# add gender into model_df
model_df <- left_join(model_df, corpus_filtered %>% 
                        distinct(name=displayName, partyAbbrev, gender, parliament_num) %>%
                        filter(!is.na(name)),
                      by=c("name", "parliament_num", "partyAbbrev"))

# identify parties with just one MP
model_df %>% 
  group_by(partyAbbrev) %>% 
  summarise(only_one_mp = n_distinct(name))

# filter out parties with just one MP
model_df <- model_df %>% 
  filter(!partyAbbrev %in% c("CA","NXT","PUP","KAP"))

# recode variables correctly
model_df <- model_df %>% 
  mutate(across(c(parliament_num, partyAbbrev, gender), ~ as.factor(.x))) %>% 
  mutate(across(c(n_statements, n_times_interjected), ~ as.numeric(.x))) %>% 
  rename(party=partyAbbrev)

# relevel parliament number and gender
model_df$parliament_num <- relevel(model_df$parliament_num, ref="47")
model_df$gender <- relevel(model_df$gender, ref="male")
model_df$party <- relevel(model_df$party, ref="ALP")

# export model_df
write_csv(model_df, "model_input.csv")
```

```{r}
# import model_df
model_df <- read_csv("model_input.csv", show_col_types = F)

# recode variables correctly
model_df <- model_df %>% 
  mutate(across(c(parliament_num, party, gender), ~ as.factor(.x))) %>% 
  mutate(across(c(n_statements, n_times_interjected), ~ as.numeric(.x)))

# relevel parliament number and gender
model_df$parliament_num <- relevel(model_df$parliament_num, ref="47")
model_df$gender <- relevel(model_df$gender, ref="male")
model_df$party <- relevel(model_df$party, ref="ALP")
```

```{r poisson}
# check for overdispersion by fitting the poisson model and looking at the ratio of residual deviance and df
poisson_mod <- glm(n_times_interjected ~ parliament_num + party + gender + offset(log(model_df$n_statements)), 
              data=model_df,family = poisson(link="log"))

# look at deviance/df ratio for overdispersion
poisson_mod$deviance/poisson_mod$df.residual

# ratio is 18.79 - rule of thumb is it should be about 1 - indicating extreme overdispersion
```

```{r neg binom}
# fit negative binomial model
mod <- glm.nb(n_times_interjected ~ parliament_num + party + gender + offset(log(model_df$n_statements)), 
              data=model_df, link=log)

# save results
saveRDS(mod, file="model_results.rds")

# look at deviance/df ratio for overdispersion
mod$deviance/mod$df.residual
# approx 1 meaning good model fit
```

```{r interaction}
mod_interaction <- glm.nb(
  n_times_interjected ~ parliament_num + party + gender + party*gender + offset(log(model_df$n_statements)), 
              data=model_df, link=log)

summary(mod_interaction)

# save results
saveRDS(mod_interaction, file="model_interaction_results.rds")
```
